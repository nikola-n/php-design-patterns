Object-oriented are design principles принципи:

-Наследување (Inheritance)
-Полиморфизам (Polymorphism)
-Абстракција (Abstraction)
-Енкапсулација (Encapsulation)


Дизајн патерни се решенија на real-world проблеми,
кои што настануваат при дизајниранње на софтвер, во форма на
blueprint/план, тестирани, докажани и бездебни за да ги следиме.

Тие се делат на три групи:

1. Creational design patterns - provides object creation mechanism
-FACTORY METHOD
-Abstract Factory
-Builder
-Prototype
-SINGLETON

2. Structural design patterns - explains how to assemble objects and classes into larger, flexible structures
-ADAPTER
-Bridge
-Composite
-DECORATOR
-Facade
-Flyweight
-Proxy

3. Behavioral design patterns - deals with algorithms and assignment of responsibilities between objects
-CHAIN OF RESPONSIBILITY
-Command
-Iterator
-Mediator
-Memento
-OBSERVER
-State
-STRATEGY
-TEMPLATE METHOD
-Visitor

Алгоритмите се исто така решение на некој познат проблем, но тие имаат
точно дефинирани чекори за да се постигне целта. (да се реши проблемот)

Патерните се висок левел на решение или објаснување на проблемот.
Секој дизајн патерн е како план кој што можеме да го кустоматизираме/измениме
за да решиме некој посебен наш проблем.

Design principles vs Design patterns

Use design patter to achieve the goals set by the design principles

1. Creational pattern - Дава механизам на креирање на различни објекти, кои ја зголемуваат
флексибилноста и реупотребата на постоечкиот код.
- Factory Method: Дава интерфејс за креирање на објекти во суперкласи, но овозможува
субкласите да го менуваат типот на објектите кои што ќе бидат креирани.

Пр. Имаме вебсајт за курир и транспортот се врши со камиони. Со камиони океј се движел бизнисот
и сега сакаме да додадеме транспорт со авион.
Цел кон е сега во Truck класа и треба да направиме голема промена ако сакаме да додадеме уште еден објект.
Подоцна може ќе сакаме да дододеме и брод.
Овој метод енкапслуира се што варира.
Структура на factory method:
Имаме creator class која е апстракна класа (abstract base class).
и Продукт (interface) која што содржи само инстанцирани методи без body of course.
Наместо во конструкторот на апстркната класа properties се креираат
во специјален abstract factory method ex. createProduct(): Product
Овој метод ќе го враќа интерфејсот.
Во сите КРЕАТОР останати(суб) класи кои ја наследуваат главната креатор апстракна класа ќе можеме да го override -неме овој метод и да го смениме
типот на продукт кои што го вракја.
Тие суб-класи се нарекуваат concrete creators.
Се креираат и ПРОДУКТ субкласи кои ќе го имплементираат познатиот интерфејс Product. Во овој интерфејс ќе се извршуваат
различни операции од методите кои ги содржи интерфејсот. ex. performTasks();
Во апстрактана КРЕАТОР главна класа имаме функција преку која подоцна ќе ги повикуваме објектите.
Во неа една варијабла се декларира на апстракниот метод и од истата се повикуваат
сите функции кои се наоѓаат во интерфејсот.
На крај имаме посебен метод кој што ќе прима КРЕАТОР апстракна класа или субкласа
и ќе го повика вториот метод од апстракната класа каде се повикуваат
операциите.

When to use it:
Uncertain about the type of objects we might have to create
and work on.
----
It separates the object creation code from code which uses
the product

- Singleton pattern: Осигурува дека класата има само една инстанца,
давајќи глобален пристап до оваа инстанца.
Пример: Конекција со база
Ако цело време праќаме реквести до база можеме да ја убиеме конецијата.
Ова не може да се постигне со регуларен конструктор бидејќи
конструкторот секогаш враќа нов објект. Затоа треба да креираме глобален објект
кој е споделен со сите класи. Ова има слабости, не е безбедно бидејќи секој дел од
апликацијата може да го override тој глобален објект.
Затоа овде се користи овој патерн.
Ни овозможува да креираме објект и ако подоцна ни текне да креираме нов
ќе го добиеме веќе креираниот. Исто така овзможува да го користеме
насекаде во програмата и да се зачува од презапишување.
Чекори на имплементација:
1. Направи го конструкторо private - ова ќе спречи други објекти да користат нов
оператор со синглетон класа.
2. Направи статичен метод - кој ќе се однесува како конструктор. Овој метод ќе го повика
контуркторот за да креира објект и да го заќува во статично поле.
Ако клиентот има пристап до singleton класата ќе има можност да го
повика статичниот метод и секогаш кога тој ќе биде повикан ќе враќа
ист објект.

When to use:
Just to have a single instance of the class available to all clients
Testing becomes an issue


------
Structural patterns
- Adapter: Дозволува објекти со инкомпатибилни интерфејси да соработуваат
Пример:
Имаме опција share во нашата Notes апликација. Апито од whats up кое се користи
има метод wShare(), а подоцна им текнува да ја променат функцијата во
weShare() и секаде кај што ние го имаме кодот треба да го смениме.
Затоа креираме адаптер класа со shareData функција кој што се справува
со whats up API или сервис класа.
Така го одвојуваме кодот на нашата апликација во друга класа која што се справува
со адаптер класата. Така секоја промена на APIто нема да ја промени
таа класа(нашиот клиент код). Кога ќе се мени АPIто ние треба
да ја промениме само адаптер класата.

-Адаптер класа служи како мост помеѓу постоечки сервис код
(АПИ) и наш апп код. (интерфејс)
-Адаптер патерн прави постоечки или нови АПИ да работат без да се промени
постоечкиот код. Само треба да се смени во адаптерот.
------------
-Декоратор
Дава ново однесување на објектите со ставање на објектите
во специјали врапер објекти кои што ги содржат овие однесувања.

Гифт риал ворлд сценарио
Пица пример.

When is used:
To assign behaviours to objects dynamically, without modifying
the code that uses the object

Used when is it complex or not possible to extend the
object's behaviour using inheritance.